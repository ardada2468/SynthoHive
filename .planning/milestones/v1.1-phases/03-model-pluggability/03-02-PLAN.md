---
phase: 03-model-pluggability
plan: 02
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - syntho_hive/interface/synthesizer.py
  - syntho_hive/tests/test_interface.py
autonomous: true
requirements:
  - MODEL-02
  - MODEL-03

must_haves:
  truths:
    - "Synthesizer(metadata, privacy) with no model argument defaults to CTGAN with no behavior change for existing callers"
    - "Synthesizer(metadata, privacy, model=StubModel) routes all orchestration through StubModel — no CTGAN instantiated"
    - "The Synthesizer model parameter is documented with supported classes and constructor convention"
    - "The deprecated backend: str parameter is removed from Synthesizer.__init__"
    - "An integration test with StubModel passes — proving MODEL-03 contract end-to-end"
  artifacts:
    - path: "syntho_hive/interface/synthesizer.py"
      provides: "Synthesizer with model parameter replacing backend: str"
      contains: "model: Type[ConditionalGenerativeModel] = CTGAN"
    - path: "syntho_hive/tests/test_interface.py"
      provides: "StubModel integration test (MODEL-03 acceptance)"
      contains: "test_stub_model_routes_through_pipeline"
  key_links:
    - from: "syntho_hive/interface/synthesizer.py"
      to: "syntho_hive/relational/orchestrator.py"
      via: "StagedOrchestrator(metadata, self.spark, model_cls=self.model_cls)"
      pattern: "model_cls=self\\.model_cls"
    - from: "syntho_hive/tests/test_interface.py"
      to: "syntho_hive/relational/orchestrator.py"
      via: "StagedOrchestrator(metadata=meta, io=mock_io, model_cls=StubModel)"
      pattern: "model_cls=StubModel"
    - from: "syntho_hive/tests/test_interface.py"
      to: "syntho_hive/core/models/base.py"
      via: "class StubModel(ConditionalGenerativeModel)"
      pattern: "class StubModel\\(ConditionalGenerativeModel\\)"
---

<objective>
Expose the model_cls injection through the Synthesizer public API, remove the dead backend: str parameter, and write the MODEL-03 integration test that proves any ConditionalGenerativeModel subclass (not just CTGAN) routes correctly through the full multi-table pipeline.

Purpose: MODEL-02 (Synthesizer.model parameter with docs + CTGAN default backward compat) and MODEL-03 (stub model routes correctly through pipeline — verified by test).
Output: Updated synthesizer.py (model param, no backend) + test_interface.py (StubModel integration test).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-model-pluggability/03-RESEARCH.md
@.planning/phases/03-model-pluggability/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace backend: str with model parameter in Synthesizer and forward to StagedOrchestrator</name>
  <files>syntho_hive/interface/synthesizer.py</files>
  <action>
Make the following changes to syntho_hive/interface/synthesizer.py:

1. ADD imports after the existing local imports (after `from syntho_hive.exceptions import ...`):
   ```python
   from typing import Type
   from syntho_hive.core.models.base import ConditionalGenerativeModel
   from syntho_hive.core.models.ctgan import CTGAN
   ```

2. CHANGE `Synthesizer.__init__` signature — replace `backend: str = "CTGAN"` with `model: Type[ConditionalGenerativeModel] = CTGAN`:

   OLD:
   ```python
   def __init__(
       self,
       metadata: Metadata,
       privacy_config: PrivacyConfig,
       spark_session: Optional[SparkSession] = None,
       backend: str = "CTGAN",
       embedding_threshold: int = 50
   ):
   ```
   NEW:
   ```python
   def __init__(
       self,
       metadata: Metadata,
       privacy_config: PrivacyConfig,
       spark_session: Optional[SparkSession] = None,
       model: Type[ConditionalGenerativeModel] = CTGAN,
       embedding_threshold: int = 50
   ):
   ```

3. UPDATE the `__init__` docstring — replace the `backend` parameter docs with `model` docs:

   OLD:
   ```
   backend: Synthesis backend identifier (currently CTGAN).
   ```
   NEW:
   ```
   model: Generative model class to use for synthesis. Must be a class
       (not an instance) that implements ``ConditionalGenerativeModel``.
       The class constructor must accept ``(metadata, batch_size, epochs,
       **kwargs)`` and instances must implement ``fit()``, ``sample()``,
       ``save()``, and ``load()``.

       Supported classes:
       - ``syntho_hive.core.models.ctgan.CTGAN`` (default)
       - Any custom class implementing ``ConditionalGenerativeModel``

       Existing callers that omit this parameter receive CTGAN behavior
       unchanged.
   ```

4. In the __init__ body, REPLACE:
   ```python
   self.backend = backend
   ```
   with:
   ```python
   self.model_cls = model
   ```

5. CHANGE the StagedOrchestrator construction inside the `if self.spark:` block from:
   ```python
   self.orchestrator = StagedOrchestrator(metadata, self.spark)
   ```
   to:
   ```python
   self.orchestrator = StagedOrchestrator(metadata, self.spark, model_cls=self.model_cls)
   ```

6. In the `sample()` method body, UPDATE the print statement from:
   ```python
   print(f"Generating data with {self.backend} backend...")
   ```
   to:
   ```python
   print(f"Generating data with {self.model_cls.__name__} backend...")
   ```

7. VERIFY: grep for any remaining reference to `self.backend` or `backend: str` — must be zero.
  </action>
  <verify>
Run from repo root:
  grep -n "self\.backend\|backend: str" syntho_hive/interface/synthesizer.py
Expected: 0 matches.

  grep -n "self\.model_cls\|model_cls=self\.model_cls" syntho_hive/interface/synthesizer.py
Expected: 2+ matches (assignment in __init__ and forwarding to StagedOrchestrator).

  python -c "
from syntho_hive.interface.synthesizer import Synthesizer
from syntho_hive.interface.config import Metadata, PrivacyConfig
m = Metadata()
m.add_table('users', 'id')
syn = Synthesizer(m, PrivacyConfig(), spark_session=None)
from syntho_hive.core.models.ctgan import CTGAN
assert syn.model_cls is CTGAN, f'Expected CTGAN default, got {syn.model_cls}'
print('Default model_cls is CTGAN: OK')
"
Expected: prints "Default model_cls is CTGAN: OK".
  </verify>
  <done>
- backend: str removed from Synthesizer.__init__ signature and body
- model: Type[ConditionalGenerativeModel] = CTGAN replaces it
- self.model_cls = model stored in __init__
- StagedOrchestrator constructed with model_cls=self.model_cls
- sample() print uses self.model_cls.__name__
- Docstring documents supported classes and constructor convention
- Default behavior for callers omitting model is unchanged (CTGAN)
  </done>
</task>

<task type="auto">
  <name>Task 2: Write StubModel integration test for MODEL-03 ABC contract verification</name>
  <files>syntho_hive/tests/test_interface.py</files>
  <action>
Append the following to the END of syntho_hive/tests/test_interface.py (after the last existing test function):

```python

# ---------------------------------------------------------------------------
# MODEL-03: ConditionalGenerativeModel ABC contract — stub model integration
# ---------------------------------------------------------------------------

import pandas as pd
from syntho_hive.core.models.base import ConditionalGenerativeModel
from syntho_hive.relational.orchestrator import StagedOrchestrator
from syntho_hive.interface.config import Metadata
from unittest.mock import MagicMock


class StubModel(ConditionalGenerativeModel):
    """Minimal stub satisfying ConditionalGenerativeModel without training.

    Stores columns seen during fit(). Returns a zero-filled DataFrame of
    correct shape on sample(). save() and load() are no-ops.
    """

    def __init__(self, metadata, batch_size=500, epochs=300, **kwargs):
        self._columns = []

    def fit(self, data: pd.DataFrame, context=None, table_name=None, **kwargs) -> None:
        self._columns = list(data.columns)

    def sample(self, num_rows: int, context=None, **kwargs) -> pd.DataFrame:
        return pd.DataFrame({col: [0] * num_rows for col in self._columns})

    def save(self, path: str) -> None:
        pass

    def load(self, path: str) -> None:
        pass


class _MockSparkDF:
    """Thin wrapper so toPandas() works in tests without a real Spark session."""
    def __init__(self, pdf: pd.DataFrame):
        self.pdf = pdf

    def toPandas(self) -> pd.DataFrame:
        return self.pdf


def test_stub_model_routes_through_pipeline(tmp_path):
    """MODEL-03: StubModel routes correctly through full orchestration pipeline.

    Verifies that StagedOrchestrator never calls CTGAN() when model_cls=StubModel
    and that the generate() result contains a DataFrame with the expected shape.
    """
    meta = Metadata()
    meta.add_table("users", pk="id")

    users_df = pd.DataFrame({"id": range(5), "age": range(20, 25)})

    mock_io = MagicMock()
    mock_io.read_dataset.return_value = _MockSparkDF(users_df)

    def _write_pandas(pdf, path, **kw):
        out = tmp_path / "users"
        out.mkdir(parents=True, exist_ok=True)
        pdf.to_csv(out / "data.csv", index=False)

    mock_io.write_pandas.side_effect = _write_pandas

    orch = StagedOrchestrator(metadata=meta, io=mock_io, model_cls=StubModel)
    orch.fit_all({"users": "path/users"}, epochs=1, batch_size=5)

    result = orch.generate({"users": 3})

    assert "users" in result, "generate() must return 'users' table"
    assert len(result["users"]) == 3, f"Expected 3 rows, got {len(result['users'])}"

    # MODEL-01 negative check: no CTGAN instance stored — only StubModel
    for table_name, model_instance in orch.models.items():
        assert isinstance(model_instance, StubModel), (
            f"StagedOrchestrator stored {type(model_instance).__name__} "
            f"for table '{table_name}' despite model_cls=StubModel"
        )
        assert type(model_instance).__name__ != "CTGAN", (
            "StagedOrchestrator stored a CTGAN instance despite model_cls=StubModel"
        )

    print("test_stub_model_routes_through_pipeline: PASSED")


def test_synthesizer_accepts_model_parameter(metadata, privacy_config):
    """MODEL-02: Synthesizer accepts model= parameter and stores it as model_cls."""
    from syntho_hive.interface.synthesizer import Synthesizer
    syn = Synthesizer(metadata, privacy_config, spark_session=None, model=StubModel)
    assert syn.model_cls is StubModel, (
        f"Expected syn.model_cls to be StubModel, got {syn.model_cls}"
    )


def test_synthesizer_default_model_is_ctgan(metadata, privacy_config):
    """MODEL-02: Synthesizer with no model= argument defaults to CTGAN."""
    from syntho_hive.interface.synthesizer import Synthesizer
    from syntho_hive.core.models.ctgan import CTGAN
    syn = Synthesizer(metadata, privacy_config, spark_session=None)
    assert syn.model_cls is CTGAN, (
        f"Expected default model_cls=CTGAN, got {syn.model_cls}"
    )


def test_issubclass_guard_rejects_invalid_model_cls():
    """MODEL-01: StagedOrchestrator raises TypeError for non-ConditionalGenerativeModel class."""
    from syntho_hive.relational.orchestrator import StagedOrchestrator
    from syntho_hive.interface.config import Metadata

    class NotAModel:
        pass

    meta = Metadata()
    meta.add_table("t", pk="id")

    with pytest.raises(TypeError, match="ConditionalGenerativeModel"):
        StagedOrchestrator(metadata=meta, model_cls=NotAModel)
```

Important notes for this task:
- The StubModel.__init__ must match the constructor convention: (self, metadata, batch_size=500, epochs=300, **kwargs) — this is what the orchestrator calls.
- The StubModel.fit() must accept table_name=None as a kwarg — the orchestrator passes table_name= when calling model.fit().
- The _MockSparkDF class mirrors the pattern used in test_relational.py for Spark mocking.
- Do NOT remove or modify any existing tests in the file — append only.
  </action>
  <verify>
Run the new tests:
  python -m pytest syntho_hive/tests/test_interface.py::test_stub_model_routes_through_pipeline -v
  python -m pytest syntho_hive/tests/test_interface.py::test_synthesizer_accepts_model_parameter -v
  python -m pytest syntho_hive/tests/test_interface.py::test_synthesizer_default_model_is_ctgan -v
  python -m pytest syntho_hive/tests/test_interface.py::test_issubclass_guard_rejects_invalid_model_cls -v

All 4 tests must pass (exit code 0).

Run full test file to confirm no regressions:
  python -m pytest syntho_hive/tests/test_interface.py -v
All tests must pass.
  </verify>
  <done>
- StubModel defined in test_interface.py implementing ConditionalGenerativeModel with constructor matching expected signature
- test_stub_model_routes_through_pipeline: StagedOrchestrator with model_cls=StubModel completes fit_all() and generate() returning correct shape
- No CTGAN instances in orch.models when model_cls=StubModel
- test_synthesizer_accepts_model_parameter: Synthesizer stores model= arg as self.model_cls
- test_synthesizer_default_model_is_ctgan: Synthesizer() with no model= defaults to CTGAN
- test_issubclass_guard_rejects_invalid_model_cls: TypeError raised for non-conforming class
- All existing tests in test_interface.py continue to pass
  </done>
</task>

</tasks>

<verification>
Full phase 03 verification after plan 03-02:

1. grep -n "backend: str\|self\.backend" syntho_hive/interface/synthesizer.py → 0 matches
2. grep -n "model_cls=self\.model_cls" syntho_hive/interface/synthesizer.py → 1 match (StagedOrchestrator construction)
3. python -m pytest syntho_hive/tests/test_interface.py -v → ALL tests pass
4. python -m pytest syntho_hive/tests/test_relational.py -v → ALL tests pass (no regression)
5. python -c "from syntho_hive.interface.synthesizer import Synthesizer; print('OK')" → prints OK
6. Manual MODEL-01 check: grep -n "CTGAN(" syntho_hive/relational/orchestrator.py → 0 matches
</verification>

<success_criteria>
- Synthesizer.model parameter replaces backend: str — backward compat preserved (default=CTGAN)
- StagedOrchestrator receives model_cls=self.model_cls when constructed in Synthesizer.__init__
- sample() uses self.model_cls.__name__ in progress print (not hardcoded "CTGAN")
- 4 new tests pass: stub routing, model= acceptance, CTGAN default, issubclass guard
- All existing test_interface.py and test_relational.py tests continue to pass
- MODEL-01, MODEL-02, MODEL-03 requirements all satisfied and verified by tests
</success_criteria>

<output>
After completion, create .planning/phases/03-model-pluggability/03-02-SUMMARY.md with:
- What changed (files, specific lines)
- Test results (paste pytest output)
- Any deviations from plan and why
</output>
