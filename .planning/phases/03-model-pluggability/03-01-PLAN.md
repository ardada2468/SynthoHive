---
phase: 03-model-pluggability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - syntho_hive/relational/orchestrator.py
  - syntho_hive/core/models/base.py
autonomous: true
requirements:
  - MODEL-01

must_haves:
  truths:
    - "StagedOrchestrator can be constructed with any ConditionalGenerativeModel subclass via model_cls parameter"
    - "StagedOrchestrator has no hardcoded CTGAN constructor calls in fit_all() — both call sites use self.model_cls()"
    - "StagedOrchestrator raises a clear TypeError at __init__ time if model_cls is not a ConditionalGenerativeModel subclass"
    - "The models dict type annotation is Dict[str, ConditionalGenerativeModel] (not Dict[str, CTGAN])"
  artifacts:
    - path: "syntho_hive/relational/orchestrator.py"
      provides: "StagedOrchestrator with model_cls dependency injection"
      contains: "model_cls: Type[ConditionalGenerativeModel] = CTGAN"
    - path: "syntho_hive/core/models/base.py"
      provides: "ConditionalGenerativeModel ABC with constructor convention docstring"
      contains: "ConditionalGenerativeModel"
  key_links:
    - from: "syntho_hive/relational/orchestrator.py"
      to: "syntho_hive/core/models/base.py"
      via: "Type[ConditionalGenerativeModel] import + model_cls parameter"
      pattern: "model_cls.*Type\\[ConditionalGenerativeModel\\]"
    - from: "syntho_hive/relational/orchestrator.py"
      to: "self.model_cls"
      via: "fit_all() constructor calls"
      pattern: "self\\.model_cls\\("
---

<objective>
Decouple StagedOrchestrator from the hardcoded CTGAN class by introducing a model_cls dependency injection parameter. This is a targeted 5-site refactor: add model_cls to __init__, store it, update the Dict type annotation, replace both CTGAN() constructor calls in fit_all(), and add an issubclass() guard. Also add a constructor convention docstring to ConditionalGenerativeModel.

Purpose: MODEL-01 — StagedOrchestrator must have no hardcoded CTGAN in orchestration logic. After this plan, any ConditionalGenerativeModel subclass can be plugged in at construction time.
Output: Modified orchestrator.py (model_cls DI) and base.py (constructor convention docstring).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-model-pluggability/03-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add model_cls parameter to StagedOrchestrator and replace all CTGAN call sites</name>
  <files>syntho_hive/relational/orchestrator.py</files>
  <action>
Make the following changes to syntho_hive/relational/orchestrator.py:

1. ADD import at the top (after existing imports, before `log = structlog.get_logger()`):
   ```python
   from typing import Type
   from syntho_hive.core.models.base import ConditionalGenerativeModel
   ```
   Note: The existing `from syntho_hive.core.models.ctgan import CTGAN` import STAYS — it is used only as the default parameter value for model_cls.

2. ADD `model_cls` parameter to `StagedOrchestrator.__init__` signature (append after `on_write_failure` param):
   ```python
   model_cls: Type[ConditionalGenerativeModel] = CTGAN,
   ```

3. ADD docstring entry for new parameter inside `__init__` docstring (after the `on_write_failure` entry):
   ```
   model_cls: Generative model class to instantiate per table. Must be a class
       (not an instance) implementing ``ConditionalGenerativeModel``. The class
       constructor must accept ``(metadata, batch_size, epochs, **kwargs)``.
       Defaults to CTGAN.
   ```

4. ADD issubclass guard at the start of the __init__ body (before `self.metadata = metadata`):
   ```python
   if not issubclass(model_cls, ConditionalGenerativeModel):
       raise TypeError(
           f"model_cls must be a subclass of ConditionalGenerativeModel, "
           f"got {model_cls!r}. Implement fit(), sample(), save(), load() "
           f"and subclass ConditionalGenerativeModel."
       )
   ```

5. ADD `self.model_cls = model_cls` in __init__ body after `self.on_write_failure = on_write_failure`.

6. CHANGE type annotation on self.models from:
   ```python
   self.models: Dict[str, CTGAN] = {}
   ```
   to:
   ```python
   self.models: Dict[str, ConditionalGenerativeModel] = {}
   ```

7. In fit_all(), REPLACE the root table constructor call (currently around line 117):
   ```python
   model = CTGAN(
       self.metadata,
       batch_size=batch_size,
       epochs=epochs,
       **model_kwargs
   )
   ```
   with:
   ```python
   model = self.model_cls(
       self.metadata,
       batch_size=batch_size,
       epochs=epochs,
       **model_kwargs
   )
   ```

8. In fit_all(), REPLACE the child table constructor call (currently around line 169):
   ```python
   model = CTGAN(
       self.metadata,
       batch_size=batch_size,
       epochs=epochs,
       **model_kwargs
   )
   ```
   with:
   ```python
   model = self.model_cls(
       self.metadata,
       batch_size=batch_size,
       epochs=epochs,
       **model_kwargs
   )
   ```

9. UPDATE the fit_all() docstring `**model_kwargs` description from "Extra parameters forwarded to CTGAN constructor" to "Extra parameters forwarded to the model constructor."

Search verification: After changes, run:
  grep -n "CTGAN(" syntho_hive/relational/orchestrator.py
This must return ZERO lines. Any remaining CTGAN( is a missed call site.
  </action>
  <verify>
Run from the repo root:
  grep -n "CTGAN(" syntho_hive/relational/orchestrator.py
Expected: no output (zero CTGAN( calls).

  grep -n "self\.model_cls(" syntho_hive/relational/orchestrator.py
Expected: 2 lines (root table + child table in fit_all).

  grep -n "model_cls.*Type\[ConditionalGenerativeModel\]" syntho_hive/relational/orchestrator.py
Expected: 1 line (the __init__ parameter).

  python -c "from syntho_hive.relational.orchestrator import StagedOrchestrator; print('import OK')"
Expected: prints "import OK" with no errors.
  </verify>
  <done>
- Zero CTGAN( constructor calls remain in orchestrator.py
- Both call sites in fit_all() use self.model_cls(
- self.models type annotation is Dict[str, ConditionalGenerativeModel]
- model_cls parameter exists in __init__ with default = CTGAN
- issubclass guard raises TypeError for non-conforming model_cls values
- Module imports cleanly
  </done>
</task>

<task type="auto">
  <name>Task 2: Add constructor convention docstring to ConditionalGenerativeModel ABC</name>
  <files>syntho_hive/core/models/base.py</files>
  <action>
In syntho_hive/core/models/base.py, update the `ConditionalGenerativeModel` class docstring to document the expected constructor signature convention.

CURRENT class docstring:
```python
class ConditionalGenerativeModel(GenerativeModel):
    """Contract for models that condition on parent context during training/sampling."""
```

CHANGE to:
```python
class ConditionalGenerativeModel(GenerativeModel):
    """Contract for models that condition on parent context during training/sampling.

    Constructor convention:
        Custom model classes passed as ``model_cls`` to ``StagedOrchestrator``
        must accept the following constructor signature::

            def __init__(self, metadata, batch_size=500, epochs=300, **kwargs):
                ...

        The ``metadata`` positional argument and ``batch_size``/``epochs`` keyword
        arguments are forwarded by the orchestrator during ``fit_all()``. Additional
        keyword arguments are forwarded from ``fit_all(**model_kwargs)``.

        Python ABCs cannot enforce constructor signatures; this convention is
        documented here so custom implementations know what is expected.
    """
```

No other changes to base.py.
  </action>
  <verify>
Run:
  python -c "from syntho_hive.core.models.base import ConditionalGenerativeModel; help(ConditionalGenerativeModel)"
Expected: help output includes "Constructor convention" section.

  python -c "
from syntho_hive.core.models.base import ConditionalGenerativeModel
import pandas as pd
class Stub(ConditionalGenerativeModel):
    def fit(self, data, context=None, **kw): pass
    def sample(self, n, context=None, **kw): return pd.DataFrame()
    def save(self, p): pass
    def load(self, p): pass
s = Stub()
print('Stub instantiation OK')
"
Expected: prints "Stub instantiation OK" — confirms ABC still enforces method contract.
  </verify>
  <done>
- ConditionalGenerativeModel class docstring documents constructor convention (metadata, batch_size, epochs, **kwargs)
- ABC still enforces fit(), sample(), save(), load() abstract methods
- Module imports cleanly
  </done>
</task>

</tasks>

<verification>
Full phase verification after plan 03-01:

1. grep -n "CTGAN(" syntho_hive/relational/orchestrator.py → 0 matches
2. grep -n "self\.model_cls(" syntho_hive/relational/orchestrator.py → exactly 2 matches
3. grep -n "Dict\[str, CTGAN\]" syntho_hive/relational/orchestrator.py → 0 matches
4. grep -n "Dict\[str, ConditionalGenerativeModel\]" syntho_hive/relational/orchestrator.py → 1 match
5. python -c "from syntho_hive.relational.orchestrator import StagedOrchestrator; print('OK')" → prints OK
6. Existing tests still pass: python -m pytest syntho_hive/tests/test_interface.py -v -k "not fit_call and not sample_call"
   (fit_call and sample_call tests use patched orchestrator, unaffected by model_cls addition)
</verification>

<success_criteria>
- StagedOrchestrator.__init__ accepts model_cls: Type[ConditionalGenerativeModel] = CTGAN
- Zero CTGAN( constructor calls remain in orchestrator.py
- self.models annotated as Dict[str, ConditionalGenerativeModel]
- issubclass() guard at __init__ time raises TypeError for invalid model_cls
- ConditionalGenerativeModel docstring documents constructor convention
- All existing tests pass unmodified
</success_criteria>

<output>
After completion, create .planning/phases/03-model-pluggability/03-01-SUMMARY.md with:
- What changed (files, specific lines)
- Verification commands run and their output
- Any deviations from plan and why
</output>
