---
phase: 01-core-reliability
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - syntho_hive/exceptions.py
  - syntho_hive/interface/synthesizer.py
  - syntho_hive/core/models/ctgan.py
  - syntho_hive/core/data/transformer.py
autonomous: true
requirements:
  - CORE-01
  - CORE-04

must_haves:
  truths:
    - "Running `grep -rn 'except:' syntho_hive/` returns zero matches (no bare except blocks)"
    - "Running `grep -rn 'except Exception: pass' syntho_hive/` returns zero matches (no silent swallows)"
    - "`from syntho_hive.exceptions import SynthoHiveError, SchemaError, TrainingError, SerializationError, ConstraintViolationError` succeeds in a Python interpreter"
    - "Synthesizer.fit(), sample(), save(), load(), generate_validation_report() catch internal exceptions and re-raise as typed SynthoHiveError subclasses using raise...from"
    - "`python -c 'from syntho_hive.exceptions import TrainingError; raise TrainingError(\"test\") from ValueError(\"inner\")'` shows chained traceback"
  artifacts:
    - path: "syntho_hive/exceptions.py"
      provides: "SynthoHiveError base class + 4 typed subclasses"
      contains: "class SynthoHiveError"
      min_lines: 25
    - path: "syntho_hive/interface/synthesizer.py"
      provides: "Public API boundary wrapping at all 5 public methods"
      contains: "from syntho_hive.exceptions import"
    - path: "syntho_hive/core/data/transformer.py"
      provides: "Bare except blocks removed; structured except with typed raises"
      contains: "from syntho_hive.exceptions import"
  key_links:
    - from: "syntho_hive/interface/synthesizer.py"
      to: "syntho_hive/exceptions.py"
      via: "import SynthoHiveError, SchemaError, TrainingError, SerializationError"
      pattern: "from syntho_hive\\.exceptions import"
    - from: "syntho_hive/core/data/transformer.py"
      to: "syntho_hive/exceptions.py"
      via: "import ConstraintViolationError"
      pattern: "ConstraintViolationError"
    - from: "syntho_hive/core/models/ctgan.py"
      to: "syntho_hive/exceptions.py"
      via: "import SerializationError, TrainingError"
      pattern: "from syntho_hive\\.exceptions import"
---

<objective>
Create the SynthoHive exception hierarchy and eliminate all bare/silent exception blocks across the codebase.

Purpose: Establish the typed exception foundation that every other Phase 1 fix builds on. Engineers must get actionable error messages instead of silent failures or cryptic tracebacks.
Output: `syntho_hive/exceptions.py` with 5 exception classes; synthesizer.py wrapping all 5 public API boundaries; transformer.py and ctgan.py with bare `except:` and silent `except Exception: pass` replaced by typed raises.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-reliability/01-CONTEXT.md
@.planning/phases/01-core-reliability/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create syntho_hive/exceptions.py with full SynthoHiveError hierarchy</name>
  <files>syntho_hive/exceptions.py</files>
  <action>
Create `syntho_hive/exceptions.py` with the following exception hierarchy (per CONTEXT.md locked decisions):

```python
"""
SynthoHive typed exception hierarchy.

All internal modules raise subclasses of SynthoHiveError.
The Synthesizer public API boundary wraps untyped exceptions into the
appropriate subclass using raise ... from exc to preserve the full traceback.
"""


class SynthoHiveError(Exception):
    """Base exception for all SynthoHive errors."""
    pass


class SchemaError(SynthoHiveError):
    """
    Raised for invalid metadata, missing FK definitions, unsupported column
    types, or invalid identifier names (e.g., SQL injection attempt via
    database/table name).
    """
    pass


class TrainingError(SynthoHiveError):
    """
    Raised for NaN loss, training divergence, GPU OOM, or any other failure
    that occurs during Synthesizer.fit().
    """
    pass


class SerializationError(SynthoHiveError):
    """
    Raised for save/load failures, corrupt checkpoints, missing checkpoint
    components, or version mismatches that prevent successful loading.
    """
    pass


class ConstraintViolationError(SynthoHiveError):
    """
    Raised when generated output violates numeric constraints (min, max,
    dtype) defined in the table Metadata.
    """
    pass
```

Also ensure `syntho_hive/__init__.py` exports the exceptions so callers can do `from syntho_hive import TrainingError`. Add to `__init__.py`:
```python
from syntho_hive.exceptions import (
    SynthoHiveError,
    SchemaError,
    TrainingError,
    SerializationError,
    ConstraintViolationError,
)
```
Check the existing `__init__.py` content first and append only if the imports are not already there.
  </action>
  <verify>
Run: `python -c "from syntho_hive.exceptions import SynthoHiveError, SchemaError, TrainingError, SerializationError, ConstraintViolationError; print('OK')"` — must print `OK`.

Run: `python -c "from syntho_hive import TrainingError; raise TrainingError('test') from ValueError('inner')"` — must show chained traceback with `The above exception was the direct cause`.
  </verify>
  <done>
`syntho_hive/exceptions.py` exists with all 5 classes. All 5 classes importable from both `syntho_hive.exceptions` and `syntho_hive`. Exception chaining via `raise ... from exc` confirmed working.
  </done>
</task>

<task type="auto">
  <name>Task 2: Audit and replace all bare except and silent exception blocks codebase-wide; wrap synthesizer public API boundaries</name>
  <files>
    syntho_hive/interface/synthesizer.py
    syntho_hive/core/models/ctgan.py
    syntho_hive/core/data/transformer.py
  </files>
  <action>
**Step 1 — Audit the codebase for bare excepts and silent swallows.**

Run the following to identify all locations:
```bash
grep -n "except:" syntho_hive/ -r
grep -n "except Exception: pass" syntho_hive/ -r
grep -n "except Exception as.*pass" syntho_hive/ -r
```

Research has identified the specific locations:
- `synthesizer.py:153` — bare `except:` inside `generate_validation_report()` delta read fallback
- `transformer.py:228` — silent `except Exception: pass` in int-casting of `inverse_transform`
- `transformer.py:245` — silent `except Exception: pass` in int-casting of `inverse_transform`

Confirm these locations by reading the files, then fix all found locations.

**Step 2 — Fix `synthesizer.py:153` bare `except:`.**

The bare `except:` around the delta read fallback catches `KeyboardInterrupt` and `SystemExit`. Replace with:
```python
except Exception as exc:
    log.warning("delta_read_fallback_failed", error=str(exc))
    raise SerializationError(
        f"SerializationError: generate_validation_report() failed reading synthetic data. "
        f"Original error: {exc}"
    ) from exc
```
Add `import structlog` and `log = structlog.get_logger()` at module level if not already present. Add `from syntho_hive.exceptions import SerializationError, TrainingError, SchemaError, SynthoHiveError` at the top of synthesizer.py.

**Step 3 — Wrap all 5 public API boundaries in synthesizer.py.**

For each public method (`fit`, `sample`, `save`, `load`, `generate_validation_report`), add a try/except around the method body:
- Already-typed `SynthoHiveError` subclasses: re-raise as-is (`except SynthoHiveError: raise`)
- All other exceptions: wrap in the appropriate typed exception using `raise TypedError("...") from exc`

Mapping:
- `fit()` → catch remaining exceptions as `TrainingError`
- `sample()` → catch remaining exceptions as `TrainingError` (sampling is part of model inference)
- `save()` → catch remaining exceptions as `SerializationError`
- `load()` → catch remaining exceptions as `SerializationError`
- `generate_validation_report()` → catch remaining exceptions as `SynthoHiveError` (generic, as it can fail for multiple reasons)

Error messages must be informative: include the method name, the data source or path if available, and the original exception via `str(exc)`.

**Step 4 — Fix `transformer.py:228` and `:245` silent swallows.**

These are in `inverse_transform()` where int-casting is attempted silently. Replace each `except Exception: pass` with a logged warning — do NOT raise here since these are internal column-wise operations where a single column failure should not abort the whole batch. Instead:
```python
except Exception as exc:
    log.warning(
        "column_cast_failed",
        column=col_name,  # use whatever variable holds the column name
        target_type="int",
        error=str(exc),
    )
    # Leave the column as-is (do not set to NaN silently)
```
Add `import structlog` and `log = structlog.get_logger()` at module level of transformer.py if not already present. Add `from syntho_hive.exceptions import ConstraintViolationError` (needed for Plan 03 but import now).

If there are any other `except:` or `except Exception: pass` found in the audit step (Step 1), fix all of them using the same pattern: replace with `except Exception as exc:` and either re-raise as the appropriate typed exception or log at WARNING level if the failure is genuinely non-fatal.
  </action>
  <verify>
Run: `grep -rn "except:" syntho_hive/` — must return zero results.
Run: `grep -rn "except Exception: pass" syntho_hive/` — must return zero results.
Run: `python -c "from syntho_hive.interface.synthesizer import Synthesizer; print('import OK')"` — must succeed.
Run: `python -m pytest tests/ -x -q --tb=short 2>&1 | head -40` — existing tests should not regress (failures pre-existing before this plan are acceptable, new failures from this plan's changes are not).
  </verify>
  <done>
Zero bare `except:` blocks in syntho_hive/. Zero silent `except Exception: pass` blocks. synthesizer.py wraps all 5 public methods with typed exception boundaries. transformer.py logs column cast failures instead of silently swallowing. All pre-existing passing tests still pass.
  </done>
</task>

</tasks>

<verification>
1. `grep -rn "except:" syntho_hive/` → zero results
2. `grep -rn "except Exception: pass" syntho_hive/` → zero results
3. `python -c "from syntho_hive.exceptions import SynthoHiveError, SchemaError, TrainingError, SerializationError, ConstraintViolationError; print('hierarchy OK')"` → prints `hierarchy OK`
4. `python -c "from syntho_hive.interface.synthesizer import Synthesizer"` → no import error
5. Exception chaining: `python -c "from syntho_hive.exceptions import TrainingError; raise TrainingError('outer') from ValueError('inner')"` → chained traceback visible
</verification>

<success_criteria>
- `syntho_hive/exceptions.py` exists with SynthoHiveError + 4 typed subclasses
- Zero bare `except:` blocks anywhere in `syntho_hive/`
- Zero silent `except Exception: pass` blocks anywhere in `syntho_hive/`
- All 5 Synthesizer public methods have typed exception wrapping
- All exception raises use `raise TypedError("...") from exc` pattern (traceback chaining preserved)
- Pre-existing passing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-reliability/01-01-SUMMARY.md`
</output>
