---
phase: 01-core-reliability
plan: "05"
type: execute
wave: 1
depends_on: []
files_modified:
  - syntho_hive/core/models/ctgan.py
  - tests/test_constraint_violation.py
autonomous: true
requirements:
  - QUAL-04
  - CORE-04
gap_closure: true

must_haves:
  truths:
    - "CTGAN.sample(enforce_constraints=True) raises ConstraintViolationError when any constraint violations are found — it does NOT return partial results silently"
    - "The ConstraintViolationError message lists every violating column with its observed value and the violated bound (e.g., 'age: got -3 (min=0); price: got -12.50 (min=0.01)')"
    - "Running `grep -n 'except Exception: pass' syntho_hive/core/models/ctgan.py` returns zero results"
    - "Running `grep -n 'except Exception:' syntho_hive/core/models/ctgan.py` shows only logged warnings — no silent swallows"
    - "pytest tests/test_constraint_violation.py passes: enforce_constraints=True raises ConstraintViolationError; enforce_constraints=False does not raise"
    - "All 8 existing tests in the Phase 1 test suite continue to pass after these changes"
  artifacts:
    - path: "syntho_hive/core/models/ctgan.py"
      provides: "Constraint violation block that raises ConstraintViolationError; silent excepts replaced with logged warnings"
      contains: "raise ConstraintViolationError"
      min_lines: 5
    - path: "tests/test_constraint_violation.py"
      provides: "TEST for QUAL-04 raise behavior — enforce_constraints=True raises, enforce_constraints=False does not"
      contains: "def test_enforce_constraints_raises"
      min_lines: 30
  key_links:
    - from: "syntho_hive/core/models/ctgan.py CTGAN.sample()"
      to: "syntho_hive/exceptions.py ConstraintViolationError"
      via: "raise ConstraintViolationError(f'...{summary}...')"
      pattern: "raise ConstraintViolationError"
    - from: "tests/test_constraint_violation.py"
      to: "syntho_hive/core/models/ctgan.py CTGAN.sample()"
      via: "pytest.raises(ConstraintViolationError) with enforce_constraints=True"
      pattern: "pytest\\.raises.*ConstraintViolationError"
---

<objective>
Close two interrelated gaps in Phase 1 that block full goal achievement: (a) QUAL-04 — change constraint violations from warn+return to raise ConstraintViolationError; (b) CORE-04 — replace three silent exception swallows in ctgan.py sample() with logged warnings. Add one test verifying the raise behavior.

Purpose: ROADMAP success criterion 4 and REQUIREMENTS.md QUAL-04 both require that violations "raise with the column name and observed value." The current warn+return implementation contradicts this contract. CORE-04 requires that all silent `except Exception: pass` blocks are eliminated — three were introduced during Plan 03.
Output: Modified ctgan.py sample() method that raises ConstraintViolationError on violation; new tests/test_constraint_violation.py verifying the raise.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-reliability/01-CONTEXT.md
@.planning/phases/01-core-reliability/01-RESEARCH.md
@.planning/phases/01-core-reliability/01-VERIFICATION.md
@.planning/phases/01-core-reliability/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix ctgan.py sample() — raise ConstraintViolationError and replace silent excepts with logged warnings</name>
  <files>syntho_hive/core/models/ctgan.py</files>
  <action>
Read `syntho_hive/core/models/ctgan.py` starting from the `enforce_constraints` block (around line 542) to understand the exact current code before making changes. Confirm the three problem locations:

- Line ~548: `except Exception: table_config = None` — silent, no log
- Line ~574: `except Exception: pass  # Non-numeric column — skip min check` — silent
- Line ~589: `except Exception: pass  # Non-numeric column — skip max check` — silent
- Lines ~592-604: violations block that logs `log.warning` and returns `result_df[valid_mask]` instead of raising

**Change 1 — Replace silent `except Exception` at line ~548 with a logged warning.**

Find the try/except block that reads:
```python
try:
    table_config = self.metadata.get_table(table_name)
except Exception:
    table_config = None
```

Replace with:
```python
try:
    table_config = self.metadata.get_table(table_name)
except Exception as exc:
    log.warning(
        "constraint_config_lookup_failed",
        table_name=table_name,
        error=str(exc),
        note="Skipping constraint enforcement — table config could not be retrieved",
    )
    table_config = None
```

**Change 2 — Replace silent `except Exception: pass` for min check at line ~574 with a logged warning.**

Find the try/except block inside the min constraint check that reads:
```python
        except Exception:
            pass  # Non-numeric column — skip min check
```

Replace with:
```python
        except Exception as exc:
            log.warning(
                "constraint_min_check_skipped",
                column=col_name,
                error=str(exc),
                note="Column is non-numeric or comparison failed — skipping min check",
            )
```

**Change 3 — Replace silent `except Exception: pass` for max check at line ~589 with a logged warning.**

Find the try/except block inside the max constraint check that reads:
```python
        except Exception:
            pass  # Non-numeric column — skip max check
```

Replace with:
```python
        except Exception as exc:
            log.warning(
                "constraint_max_check_skipped",
                column=col_name,
                error=str(exc),
                note="Column is non-numeric or comparison failed — skipping max check",
            )
```

**Change 4 — Change the violations block to RAISE instead of warn+return.**

Find the violations block that currently reads (approximately lines 592-604):
```python
                if violations:
                    summary = "; ".join(violations)
                    log.warning(
                        "constraint_violations_detected",
                        violation_count=len(violations),
                        violations=summary,
                        valid_rows=int(valid_mask.sum()),
                        total_rows=len(result_df),
                        action="returning valid rows only",
                    )
                    # Per CONTEXT.md decision: return valid rows, warn about violations.
                    # Caller decides whether the violation rate is acceptable.
                    result_df = result_df[valid_mask].reset_index(drop=True)
```

Replace with:
```python
                if violations:
                    summary = "; ".join(violations)
                    raise ConstraintViolationError(
                        f"ConstraintViolationError: {len(violations)} violation(s) found — "
                        f"{summary}"
                    )
```

**Rationale note to include as a comment above the raise:**
```python
                    # ROADMAP success criterion 4 and REQUIREMENTS.md QUAL-04 require
                    # violations to "raise with the column name and observed value".
                    # Use sample(enforce_constraints=False) (the default) if you want
                    # the previous warn-and-return behavior.
```

Ensure `ConstraintViolationError` is imported at the top of ctgan.py. Verify by checking the existing imports — `from syntho_hive.exceptions import SerializationError, TrainingError` should already be there. Add `ConstraintViolationError` to that import line if it is not already included.

Do NOT touch any other part of ctgan.py. The rest of the sample() method (seed setting, generation loop, inverse_transform) remains unchanged.
  </action>
  <verify>
```bash
# No silent swallows remain
grep -n "except Exception: pass" /Users/arnavdadarya/FedEx/SynthoHive/syntho_hive/core/models/ctgan.py
# Must return zero lines

# ConstraintViolationError is raised
grep -n "raise ConstraintViolationError" /Users/arnavdadarya/FedEx/SynthoHive/syntho_hive/core/models/ctgan.py
# Must show at least one match

# Bare silent except is gone — all except Exception now have "as exc:"
grep -n "except Exception:" /Users/arnavdadarya/FedEx/SynthoHive/syntho_hive/core/models/ctgan.py
# All results must include "as exc:" — none may be bare "except Exception:" on their own

# Syntax check
python -c "import syntho_hive.core.models.ctgan; print('Import OK')"
```
  </verify>
  <done>
- Zero `except Exception: pass` lines in ctgan.py
- All three former silent-swallow excepts now log a warning via structlog with the error and context
- `raise ConstraintViolationError(f"...{summary}...")` present in the violations block
- ctgan.py imports cleanly with no syntax errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Write test_constraint_violation.py verifying raise behavior and run full test suite</name>
  <files>tests/test_constraint_violation.py</files>
  <action>
Read `tests/test_e2e_single_table.py` and `tests/test_serialization.py` to understand the exact fixture pattern used (small_dataset, meta, CTGAN constructor args) so this file is consistent with the existing test suite.

Read `syntho_hive/interface/config.py` to find whether `Metadata.add_table()` accepts a `constraints` parameter or whether column-level constraints are added separately. You need to create a table with at least one constraint (min or max) that the generated data will violate so the test can force a violation path.

If `Metadata` does not support column-level constraints natively (i.e., there is no way to add min/max constraints to a column via the config API), then construct the test as follows: verify the *parameter contract* — that `sample(enforce_constraints=True)` raises `ConstraintViolationError` when violations exist, and that `sample(enforce_constraints=False)` does not raise. Use a mock or monkeypatching approach to inject a fake `table_config.constraints` dict if no real API exists for constraints.

Write `tests/test_constraint_violation.py`:

```python
"""
QUAL-04 regression test: enforce_constraints=True raises ConstraintViolationError.

Gap closure for Phase 1 verification failure — the original Plan 03 implementation
logged a warning and returned valid rows instead of raising. This test verifies the
corrected behavior: violations raise ConstraintViolationError with column and value details.
"""
import pandas as pd
import numpy as np
import pytest
from unittest.mock import MagicMock, patch
from syntho_hive.core.models.ctgan import CTGAN
from syntho_hive.interface.config import Metadata
from syntho_hive.exceptions import ConstraintViolationError


@pytest.fixture
def small_dataset():
    np.random.seed(0)
    return pd.DataFrame({
        "id": range(200),
        "age": np.random.randint(18, 80, 200),
        "income": np.random.exponential(50_000, 200),
        "city": np.random.choice(["NY", "SF", "LA"], 200),
    })


@pytest.fixture
def meta():
    m = Metadata()
    m.add_table("customers", pk="id")
    return m


@pytest.fixture
def trained_model(small_dataset, meta):
    """A trained CTGAN model for use across constraint tests."""
    model = CTGAN(
        meta,
        batch_size=32,
        epochs=3,
        embedding_dim=16,
        generator_dim=(32, 32),
        discriminator_dim=(32, 32),
    )
    model.fit(small_dataset, table_name="customers", seed=42)
    return model


def _make_constraint(min_val=None, max_val=None):
    """Build a simple constraint mock with .min and .max attributes."""
    c = MagicMock()
    c.min = min_val
    c.max = max_val
    return c


def _inject_constraints(model, table_name, constraints_dict):
    """
    Inject a fake table config with the given constraints dict into model.metadata
    so that sample(enforce_constraints=True) will process them.

    constraints_dict: {col_name: mock_constraint_with_min_max}
    """
    table_config = MagicMock()
    table_config.constraints = constraints_dict
    model.metadata = MagicMock()
    model.metadata.get_table.return_value = table_config
    # Make transformer expose table_name so the lookup is triggered
    model.transformer.table_name = table_name


def _make_df_with_violation():
    """Return a DataFrame with a column that will violate a min=0 constraint."""
    return pd.DataFrame({
        "age": [-5, 25, 30],       # -5 violates min=0
        "income": [50000, 60000, 70000],
        "city": ["NY", "SF", "LA"],
    })


def test_enforce_constraints_raises_on_violation(trained_model):
    """
    sample(enforce_constraints=True) must raise ConstraintViolationError when
    generated data contains a constraint violation — not warn-and-return.

    This test patches the sample output to guarantee a violation so the test
    does not depend on probabilistic model output.
    """
    # Inject a constraint: age must be >= 0
    _inject_constraints(
        trained_model,
        "customers",
        {"age": _make_constraint(min_val=0)},
    )

    # Patch inverse_transform to return a DataFrame that definitely violates age >= 0
    violating_df = _make_df_with_violation()
    with patch.object(trained_model.transformer, "inverse_transform",
                      return_value=violating_df):
        with pytest.raises(ConstraintViolationError) as exc_info:
            trained_model.sample(3, enforce_constraints=True, seed=7)

    # Error message must include column name and observed value
    error_msg = str(exc_info.value)
    assert "age" in error_msg, (
        f"ConstraintViolationError message must name the violating column 'age'. Got: {error_msg}"
    )
    assert "min=" in error_msg or "got" in error_msg, (
        f"ConstraintViolationError message must include observed value context. Got: {error_msg}"
    )


def test_enforce_constraints_false_does_not_raise(trained_model):
    """
    sample(enforce_constraints=False) (the default) must not raise even when
    generated data contains constraint violations — it returns whatever the model generates.
    """
    # Inject the same constraint
    _inject_constraints(
        trained_model,
        "customers",
        {"age": _make_constraint(min_val=0)},
    )

    violating_df = _make_df_with_violation()
    with patch.object(trained_model.transformer, "inverse_transform",
                      return_value=violating_df):
        # Must not raise — constraint checking is opt-in
        result = trained_model.sample(3, enforce_constraints=False, seed=7)

    assert result is not None
    assert len(result) == 3


def test_enforce_constraints_no_violation_does_not_raise(trained_model):
    """
    sample(enforce_constraints=True) must not raise when no violations exist.
    """
    _inject_constraints(
        trained_model,
        "customers",
        {"age": _make_constraint(min_val=0)},
    )

    clean_df = pd.DataFrame({
        "age": [25, 30, 45],        # all >= 0 — no violation
        "income": [50000, 60000, 70000],
        "city": ["NY", "SF", "LA"],
    })
    with patch.object(trained_model.transformer, "inverse_transform",
                      return_value=clean_df):
        result = trained_model.sample(3, enforce_constraints=True, seed=7)

    assert result is not None
    assert len(result) == 3


def test_enforce_constraints_error_message_format(trained_model):
    """
    ConstraintViolationError message follows the expected format:
    'ConstraintViolationError: N violation(s) found — col: got X (min/max=Y)'
    """
    _inject_constraints(
        trained_model,
        "customers",
        {
            "age": _make_constraint(min_val=0),
            "income": _make_constraint(max_val=100_000),
        },
    )

    # Both age and income violate their constraints
    double_violation_df = pd.DataFrame({
        "age": [-10, 25, 30],         # -10 violates min=0
        "income": [200_000, 60_000, 70_000],  # 200_000 violates max=100_000
        "city": ["NY", "SF", "LA"],
    })
    with patch.object(trained_model.transformer, "inverse_transform",
                      return_value=double_violation_df):
        with pytest.raises(ConstraintViolationError) as exc_info:
            trained_model.sample(3, enforce_constraints=True, seed=7)

    error_msg = str(exc_info.value)
    # Both columns must appear in the error message
    assert "age" in error_msg
    assert "income" in error_msg
```

After writing the file, run the full test suite:

```bash
cd /Users/arnavdadarya/FedEx/SynthoHive && python -m pytest tests/test_constraint_violation.py -v --tb=short 2>&1 | tail -30
```

Then run all Phase 1 tests to confirm no regressions:

```bash
cd /Users/arnavdadarya/FedEx/SynthoHive && python -m pytest tests/test_e2e_single_table.py tests/test_serialization.py tests/test_seed_regression.py tests/test_constraint_violation.py -v --tb=short 2>&1 | tail -40
```

If any test fails in `test_constraint_violation.py`, diagnose carefully:
- If `trained_model.transformer` does not have a `table_name` attribute, find the actual attribute on the transformer that holds the table name, and update `_inject_constraints()` accordingly.
- If `model.metadata` does not exist as an attribute or is structured differently, read ctgan.py to find how `metadata.get_table()` is called in the enforce_constraints block, and update the mock injection to match.
- If `inverse_transform` is on a different object than `model.transformer`, update the patch target.

Do NOT alter the test's expectations (enforce_constraints=True must raise, enforce_constraints=False must not raise). Only adjust the mocking mechanics to match the actual ctgan.py structure.
  </action>
  <verify>
```bash
python -m pytest /Users/arnavdadarya/FedEx/SynthoHive/tests/test_constraint_violation.py -v --tb=short 2>&1 | tail -20
# Must show: 4 passed

python -m pytest /Users/arnavdadarya/FedEx/SynthoHive/tests/ -x -q --tb=short 2>&1 | tail -15
# Must show: 12 passed (8 existing + 4 new), 0 failed
```
  </verify>
  <done>
- tests/test_constraint_violation.py exists with 4 passing tests
- test_enforce_constraints_raises_on_violation: PASS — ConstraintViolationError raised with column name and observed value
- test_enforce_constraints_false_does_not_raise: PASS — no raise when enforce_constraints=False
- test_enforce_constraints_no_violation_does_not_raise: PASS — no raise when no violations
- test_enforce_constraints_error_message_format: PASS — message contains both violating column names
- All 8 existing Phase 1 tests still pass
  </done>
</task>

</tasks>

<verification>
1. `grep -n "except Exception: pass" syntho_hive/core/models/ctgan.py` — zero results
2. `grep -n "raise ConstraintViolationError" syntho_hive/core/models/ctgan.py` — at least one match
3. `grep -n "except Exception:" syntho_hive/core/models/ctgan.py` — all results include "as exc:" (no bare silent swallows)
4. `python -m pytest tests/test_constraint_violation.py -v` — 4 tests PASS
5. `python -m pytest tests/ -x -q` — 12 tests PASS, 0 FAILED (no regressions)
6. `python -c "from syntho_hive.core.models.ctgan import CTGAN; print('OK')"` — imports cleanly
</verification>

<success_criteria>
- ctgan.py sample() raises ConstraintViolationError (not warns+returns) when enforce_constraints=True and violations exist
- Error message includes every violating column name and its observed vs. expected value
- Three former silent exception swallows (lines ~548, ~574, ~589) now log structlog warnings
- tests/test_constraint_violation.py: 4 tests pass
- Full test suite: all 12 tests pass (8 existing + 4 new)
- QUAL-04 status: SATISFIED — ConstraintViolationError is raised with column name and observed value
- CORE-04 status: SATISFIED — zero silent exception swallows anywhere in syntho_hive/
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-reliability/01-05-SUMMARY.md`
</output>
